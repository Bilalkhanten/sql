class SQL::Parser

rule

# queries
  query_specification:
    SELECT derived_column { result = SQL::Statement::Select.new(val[1]) }

  derived_column:
    value_expression

# search condition
  value_expression:
    numeric_value_expression

  numeric_value_expression:
    term plus_sign numeric_value_expression { result = SQL::Statement::Add.new(val[0], val[2]) }
    | term minus_sign numeric_value_expression { result = SQL::Statement::Subtract.new(val[0], val[2]) }
    | term

  term:
    factor asterisk term { result = SQL::Statement::Multiply.new(val[0], val[2]) }
    | factor solidus term { result = SQL::Statement::Divide.new(val[0], val[2]) }
    | factor

  factor:
    # NOTE: shortcut.  this is wrong.
    literal

# literals
  literal:
    signed_numeric_literal
    | general_literal

  general_literal:
    character_string_literal { result = SQL::Statement::String.new(val[0]) }
    | datetime_literal

  datetime_literal:
    date_literal

  date_literal:
    DATE date_string { result = SQL::Statement::Date.new(val[1]) }

  signed_numeric_literal:
    plus_sign exact_numeric_literal { result = SQL::Statement::UnaryPlus.new(val[1]) }
    | minus_sign exact_numeric_literal { result = SQL::Statement::UnaryMinus.new(val[1]) }
    | exact_numeric_literal

  exact_numeric_literal:
    unsigned_integer period unsigned_integer { result = SQL::Statement::Float.new("#{val[0]}.#{val[2]}".to_f) }
    | unsigned_integer period { result = SQL::Statement::Float.new(val[0]) }
    | period unsigned_integer { result = SQL::Statement::Float.new("0.#{val[1]}".to_f) }
    | unsigned_integer { result = SQL::Statement::Integer.new(val[0]) }

---- header ----
require File.dirname(__FILE__) + '/parser.rex.rb'

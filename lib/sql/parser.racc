class SQL::Parser

rule

# queries
  query_specification:
    SELECT select_list table_expression { result = SQL::Statement::Select.new(val[1], val[2]) }
    | SELECT select_list { result = SQL::Statement::Select.new(val[1]) }

  select_list:
    asterisk { result = SQL::Statement::All.new }
    | select_sublist { result = SQL::Statement::SelectList.new(val[0]) }

  select_sublist:
    derived_column comma select_sublist { result = [val[0]] + Array(val[2]) }
    | derived_column

  derived_column:
    value_expression AS column_name { result = SQL::Statement::As.new(val[0], val[2]) }
    | value_expression

  table_expression:
    from_clause

  from_clause:
    FROM table_reference { result = SQL::Statement::FromClause.new(val[1]) }

  table_reference:
    table_name { result = SQL::Statement::Table.new(val[0]) }

# constraints
  table_name:
    identifier

# search condition
  value_expression:
    numeric_value_expression

  numeric_value_expression:
    term plus_sign numeric_value_expression { result = SQL::Statement::Add.new(val[0], val[2]) }
    | term minus_sign numeric_value_expression { result = SQL::Statement::Subtract.new(val[0], val[2]) }
    | term

  term:
    factor asterisk term { result = SQL::Statement::Multiply.new(val[0], val[2]) }
    | factor solidus term { result = SQL::Statement::Divide.new(val[0], val[2]) }
    | factor

  factor:
    plus_sign value_expression_primary { result = SQL::Statement::UnaryPlus.new(val[1]) }
    | minus_sign value_expression_primary { result = SQL::Statement::UnaryMinus.new(val[1]) }
    | value_expression_primary

  value_expression_primary:
    unsigned_literal
    | column_reference
    | left_paren value_expression right_paren { result = val[1] }

  unsigned_literal:
    unsigned_numeric_literal
    | general_literal

  column_reference:
    column_name { result = SQL::Statement::Column.new(val[0]) }

# sql module
  column_name:
    identifier

# literals
  general_literal:
    character_string_literal { result = SQL::Statement::String.new(val[0]) }
    | datetime_literal

  datetime_literal:
    date_literal

  date_literal:
    DATE date_string { result = SQL::Statement::Date.new(val[1]) }

  unsigned_numeric_literal:
    exact_numeric_literal

  exact_numeric_literal:
    unsigned_integer period unsigned_integer { result = SQL::Statement::Float.new("#{val[0]}.#{val[2]}".to_f) }
    | unsigned_integer period { result = SQL::Statement::Float.new(val[0]) }
    | period unsigned_integer { result = SQL::Statement::Float.new("0.#{val[1]}".to_f) }
    | unsigned_integer { result = SQL::Statement::Integer.new(val[0]) }

---- header ----
require File.dirname(__FILE__) + '/parser.rex.rb'

---- inner ----

def self.parse(sql)
  new.scan_str(sql)
end

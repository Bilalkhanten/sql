class SQL::Parser

rule

# queries
  query_specification:
    SELECT derived_column { result = SQL::Statement::Select.new(val[1]) }

  derived_column:
    value_expression

# search condition
  value_expression:
    numeric_value_expression

  numeric_value_expression:
    term plus_sign numeric_value_expression { result = SQL::Statement::Add.new(val[0], val[2]) }
    | term minus_sign numeric_value_expression { result = SQL::Statement::Subtract.new(val[0], val[2]) }
    | term

  term:
    factor asterisk term { result = SQL::Statement::Multiply.new(val[0], val[2]) }
    | factor solidus term { result = SQL::Statement::Divide.new(val[0], val[2]) }
    | factor

  factor:
    plus_sign value_expression_primary { result = SQL::Statement::UnaryPlus.new(val[1]) }
    | minus_sign value_expression_primary { result = SQL::Statement::UnaryMinus.new(val[1]) }
    | value_expression_primary

  value_expression_primary:
    unsigned_literal
    | left_paren value_expression right_paren { result = val[1] }

  unsigned_literal:
    unsigned_numeric_literal
    | general_literal

# literals
  general_literal:
    character_string_literal { result = SQL::Statement::String.new(val[0]) }
    | datetime_literal

  datetime_literal:
    date_literal

  date_literal:
    DATE date_string { result = SQL::Statement::Date.new(val[1]) }

  unsigned_numeric_literal:
    exact_numeric_literal

  exact_numeric_literal:
    unsigned_integer period unsigned_integer { result = SQL::Statement::Float.new("#{val[0]}.#{val[2]}".to_f) }
    | unsigned_integer period { result = SQL::Statement::Float.new(val[0]) }
    | period unsigned_integer { result = SQL::Statement::Float.new("0.#{val[1]}".to_f) }
    | unsigned_integer { result = SQL::Statement::Integer.new(val[0]) }

---- header ----
require File.dirname(__FILE__) + '/parser.rex.rb'

---- inner ----

def self.parse(sql)
  new.scan_str(sql)
end
